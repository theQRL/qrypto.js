import { expect } from 'chai';
import { CryptoPublicKeyBytes, CryptoSecretKeyBytes, CryptoBytes } from '../src/const.js';
import { cryptoSignKeypair, cryptoSignVerify, cryptoSign } from '../src/sign.js';
import { MLDSA87_VECTORS } from './cross-vectors.js';

// Cross-implementation verification tests
// These tests verify that qrypto.js produces the same keys and signatures as go-qrllib
//
// IMPORTANT: Unlike Dilithium5, ML-DSA-87 does NOT pre-hash the seed in go-qrllib.
// Both implementations should produce identical keys from the same raw seed.

describe('Cross-Verification: go-qrllib → qrypto.js (ML-DSA-87)', () => {
  describe('Key Generation', () => {
    MLDSA87_VECTORS.forEach((vec, i) => {
      it(`should generate identical keys from raw seed (vector ${i})`, () => {
        // ML-DSA-87 uses raw seed directly (no pre-hashing like Dilithium5)
        const seed = Buffer.from(vec.rawSeed, 'hex');

        const pk = new Uint8Array(CryptoPublicKeyBytes);
        const sk = new Uint8Array(CryptoSecretKeyBytes);
        cryptoSignKeypair(seed, pk, sk);

        // Compare public keys
        const expectedPk = vec.pk;
        const actualPk = Buffer.from(pk).toString('hex');
        expect(actualPk).to.equal(expectedPk, `Public key mismatch for vector ${i}`);

        // Compare secret keys
        const expectedSk = vec.sk;
        const actualSk = Buffer.from(sk).toString('hex');
        expect(actualSk).to.equal(expectedSk, `Secret key mismatch for vector ${i}`);
      });
    });
  });

  describe('Signature Verification', () => {
    MLDSA87_VECTORS.forEach((vec, i) => {
      it(`should verify go-qrllib signatures (vector ${i})`, () => {
        const pk = Buffer.from(vec.pk, 'hex');
        const sig = Buffer.from(vec.sig, 'hex');
        const msg = Buffer.from(vec.message, 'hex');
        const ctx = Buffer.from(vec.ctx, 'hex');

        // Verify signature generated by go-qrllib
        const valid = cryptoSignVerify(sig, msg, pk, ctx);
        expect(valid).to.equal(true, `Failed to verify go-qrllib signature for vector ${i}`);
      });
    });
  });

  describe('Signature Generation', () => {
    MLDSA87_VECTORS.forEach((vec, i) => {
      it(`should generate identical signatures as go-qrllib (vector ${i})`, () => {
        // Use raw seed (ML-DSA-87 has no pre-hashing)
        const seed = Buffer.from(vec.rawSeed, 'hex');
        const msg = Buffer.from(vec.message, 'hex');
        const ctx = Buffer.from(vec.ctx, 'hex');

        const pk = new Uint8Array(CryptoPublicKeyBytes);
        const sk = new Uint8Array(CryptoSecretKeyBytes);
        cryptoSignKeypair(seed, pk, sk);

        // Sign with qrypto.js (non-randomized)
        const signedMsg = cryptoSign(msg, sk, false, ctx);
        const sig = Buffer.from(signedMsg.slice(0, CryptoBytes)).toString('hex');

        // Compare with go-qrllib signature
        expect(sig).to.equal(vec.sig, `Signature mismatch for vector ${i}`);
      });
    });
  });

  describe('Cross-Sign-Verify', () => {
    MLDSA87_VECTORS.forEach((vec, i) => {
      it(`should sign with qrypto.js and verify matches go-qrllib (vector ${i})`, () => {
        // Generate keys with qrypto.js using raw seed
        const seed = Buffer.from(vec.rawSeed, 'hex');
        const msg = Buffer.from(vec.message, 'hex');
        const ctx = Buffer.from(vec.ctx, 'hex');

        const pk = new Uint8Array(CryptoPublicKeyBytes);
        const sk = new Uint8Array(CryptoSecretKeyBytes);
        cryptoSignKeypair(seed, pk, sk);

        // Sign with qrypto.js
        const signedMsg = cryptoSign(msg, sk, false, ctx);
        const qryptoSig = Buffer.from(signedMsg.slice(0, CryptoBytes));

        // Verify qrypto.js signature with go-qrllib public key
        const goQrlibPk = Buffer.from(vec.pk, 'hex');
        expect(cryptoSignVerify(qryptoSig, msg, goQrlibPk, ctx)).to.equal(true);

        // Verify go-qrllib signature with qrypto.js public key
        const goQrlibSig = Buffer.from(vec.sig, 'hex');
        expect(cryptoSignVerify(goQrlibSig, msg, Buffer.from(pk), ctx)).to.equal(true);
      });
    });
  });
});

describe('Cross-Verification: ML-DSA-87 Interoperability Notes', () => {
  it('should document seed processing (no pre-hashing)', () => {
    // This test documents the seed processing for ML-DSA-87
    //
    // Unlike Dilithium5, ML-DSA-87 does NOT pre-hash the seed with SHAKE256.
    // Both go-qrllib and qrypto.js use the same seed expansion:
    //   seed → SHAKE256(seed || [K, L]) → (rho, rhoPrime, key)
    //
    // This means the raw seed produces identical keys in both implementations.

    const { rawSeed } = MLDSA87_VECTORS[0];
    const { hashedSeed } = MLDSA87_VECTORS[0];

    // For ML-DSA-87, we use rawSeed (not hashedSeed)
    expect(rawSeed).to.equal('0000000000000000000000000000000000000000000000000000000000000000');

    // The hashedSeed is provided for reference but NOT used in ML-DSA-87
    expect(hashedSeed).to.equal('f5977c8283546a63723bc31d2619124f11db4658643336741df81757d5ad3062');
  });

  it('should verify context parameter handling matches go-qrllib', () => {
    // Both implementations use the same context parameter format
    // go-qrllib uses []byte("ZOND") = 5a4f4e44 (hex)
    const expectedCtx = '5a4f4e44';
    expect(MLDSA87_VECTORS[0].ctx).to.equal(expectedCtx);
  });
});
