import { expect } from 'chai';
import { CryptoPublicKeyBytes, CryptoSecretKeyBytes, CryptoBytes } from '../src/const.js';
import { cryptoSignKeypair, cryptoSignVerify, cryptoSign } from '../src/sign.js';
import { DILITHIUM5_VECTORS } from './cross-vectors.js';

// Cross-implementation verification tests
// These tests verify that qrypto.js produces the same keys and signatures as go-qrllib

describe('Cross-Verification: go-qrllib → qrypto.js', () => {
  describe('Key Generation', () => {
    DILITHIUM5_VECTORS.forEach((vec, i) => {
      it(`should generate identical keys from hashed seed (vector ${i})`, () => {
        // Use hashedSeed (not rawSeed) because go-qrllib pre-hashes with SHAKE256
        const seed = Buffer.from(vec.hashedSeed, 'hex');

        const pk = new Uint8Array(CryptoPublicKeyBytes);
        const sk = new Uint8Array(CryptoSecretKeyBytes);
        cryptoSignKeypair(seed, pk, sk);

        // Compare public keys
        const expectedPk = vec.pk;
        const actualPk = Buffer.from(pk).toString('hex');
        expect(actualPk).to.equal(expectedPk, `Public key mismatch for vector ${i}`);

        // Compare secret keys
        const expectedSk = vec.sk;
        const actualSk = Buffer.from(sk).toString('hex');
        expect(actualSk).to.equal(expectedSk, `Secret key mismatch for vector ${i}`);
      });
    });
  });

  describe('Signature Verification', () => {
    DILITHIUM5_VECTORS.forEach((vec, i) => {
      it(`should verify go-qrllib signatures (vector ${i})`, () => {
        const pk = Buffer.from(vec.pk, 'hex');
        const sig = Buffer.from(vec.sig, 'hex');
        const msg = Buffer.from(vec.message, 'hex');

        // Verify signature generated by go-qrllib
        const valid = cryptoSignVerify(sig, msg, pk);
        expect(valid).to.equal(true, `Failed to verify go-qrllib signature for vector ${i}`);
      });
    });
  });

  describe('Signature Generation', () => {
    DILITHIUM5_VECTORS.forEach((vec, i) => {
      it(`should generate identical signatures as go-qrllib (vector ${i})`, () => {
        // Use hashedSeed to get the same keys
        const seed = Buffer.from(vec.hashedSeed, 'hex');
        const msg = Buffer.from(vec.message, 'hex');

        const pk = new Uint8Array(CryptoPublicKeyBytes);
        const sk = new Uint8Array(CryptoSecretKeyBytes);
        cryptoSignKeypair(seed, pk, sk);

        // Sign with qrypto.js (non-randomized)
        const signedMsg = cryptoSign(msg, sk, false);
        const sig = Buffer.from(signedMsg.slice(0, CryptoBytes)).toString('hex');

        // Compare with go-qrllib signature
        expect(sig).to.equal(vec.sig, `Signature mismatch for vector ${i}`);
      });
    });
  });

  describe('Cross-Sign-Verify', () => {
    DILITHIUM5_VECTORS.forEach((vec, i) => {
      it(`should sign with qrypto.js and verify matches go-qrllib (vector ${i})`, () => {
        // Generate keys with qrypto.js using hashedSeed
        const seed = Buffer.from(vec.hashedSeed, 'hex');
        const msg = Buffer.from(vec.message, 'hex');

        const pk = new Uint8Array(CryptoPublicKeyBytes);
        const sk = new Uint8Array(CryptoSecretKeyBytes);
        cryptoSignKeypair(seed, pk, sk);

        // Sign with qrypto.js
        const signedMsg = cryptoSign(msg, sk, false);
        const qryptoSig = Buffer.from(signedMsg.slice(0, CryptoBytes));

        // Verify qrypto.js signature with go-qrllib public key
        const goQrlibPk = Buffer.from(vec.pk, 'hex');
        expect(cryptoSignVerify(qryptoSig, msg, goQrlibPk)).to.equal(true);

        // Verify go-qrllib signature with qrypto.js public key
        const goQrlibSig = Buffer.from(vec.sig, 'hex');
        expect(cryptoSignVerify(goQrlibSig, msg, Buffer.from(pk))).to.equal(true);
      });
    });
  });
});

describe('Cross-Verification: Interoperability Notes', () => {
  it('should document seed processing difference', () => {
    // This test documents the seed processing difference between implementations
    //
    // go-qrllib: seed → SHAKE256(seed)[:32] → cryptoSignKeypair
    // qrypto.js: seed → SHAKE256(seed)[:128] → uses rho, rhoPrime, key
    //
    // To achieve interoperability:
    // - Use go-qrllib's "hashedSeed" (SHAKE256 of raw seed) as qrypto.js input
    // - Or use qrypto.js's seed directly without go-qrllib's pre-hashing

    const { hashedSeed } = DILITHIUM5_VECTORS[0];

    // The hashedSeed should be SHAKE256(zeroed raw seed)
    // Raw seed: 0000...0000 (32 bytes of zeros)
    expect(hashedSeed).to.equal('f5977c8283546a63723bc31d2619124f11db4658643336741df81757d5ad3062');

    // This is the seed that qrypto.js should use to match go-qrllib's output
    expect(Buffer.from(hashedSeed, 'hex').length).to.equal(32);
  });
});
