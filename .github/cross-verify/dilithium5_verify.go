// +build ignore

// Verify a Dilithium5 signature generated by qrypto.js using go-qrllib.
// Reads: /tmp/qrypto_dilithium5_pk.bin, /tmp/qrypto_dilithium5_sig.bin, /tmp/qrypto_dilithium5_msg.bin

package main

import (
	"fmt"
	"os"

	"github.com/theQRL/go-qrllib/crypto/dilithium"
)

func main() {
	fmt.Println("=== go-qrllib Dilithium5 Signature Verification ===")

	// Read qrypto.js generated files
	pk, err := os.ReadFile("/tmp/qrypto_dilithium5_pk.bin")
	if err != nil {
		fmt.Printf("Failed to read public key: %v\n", err)
		os.Exit(1)
	}

	sig, err := os.ReadFile("/tmp/qrypto_dilithium5_sig.bin")
	if err != nil {
		fmt.Printf("Failed to read signature: %v\n", err)
		os.Exit(1)
	}

	msg, err := os.ReadFile("/tmp/qrypto_dilithium5_msg.bin")
	if err != nil {
		fmt.Printf("Failed to read message: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Public key size: %d bytes\n", len(pk))
	fmt.Printf("Signature size: %d bytes\n", len(sig))
	fmt.Printf("Message size: %d bytes\n", len(msg))
	fmt.Printf("Message: %q\n", string(msg))

	// Convert to fixed-size arrays
	var pkArray [dilithium.CRYPTO_PUBLIC_KEY_BYTES]uint8
	var sigArray [dilithium.CRYPTO_BYTES]uint8

	if len(pk) != dilithium.CRYPTO_PUBLIC_KEY_BYTES {
		fmt.Printf("Invalid public key size: expected %d, got %d\n", dilithium.CRYPTO_PUBLIC_KEY_BYTES, len(pk))
		os.Exit(1)
	}
	if len(sig) != dilithium.CRYPTO_BYTES {
		fmt.Printf("Invalid signature size: expected %d, got %d\n", dilithium.CRYPTO_BYTES, len(sig))
		os.Exit(1)
	}

	copy(pkArray[:], pk)
	copy(sigArray[:], sig)

	// Verify signature
	valid := dilithium.Verify(msg, sigArray, &pkArray)

	if valid {
		fmt.Println("\n✓ Signature verification PASSED")
		os.Exit(0)
	} else {
		fmt.Println("\n✗ Signature verification FAILED")
		os.Exit(1)
	}
}
