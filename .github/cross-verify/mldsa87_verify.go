// +build ignore

// Verify an ML-DSA-87 signature generated by qrypto.js using go-qrllib.
// Reads: /tmp/qrypto_mldsa87_pk.bin, /tmp/qrypto_mldsa87_sig.bin, /tmp/qrypto_mldsa87_msg.bin, /tmp/qrypto_mldsa87_ctx.bin

package main

import (
	"fmt"
	"os"

	"github.com/theQRL/go-qrllib/crypto/ml_dsa_87"
)

func main() {
	fmt.Println("=== go-qrllib ML-DSA-87 Signature Verification ===")

	// Read qrypto.js generated files
	pk, err := os.ReadFile("/tmp/qrypto_mldsa87_pk.bin")
	if err != nil {
		fmt.Printf("Failed to read public key: %v\n", err)
		os.Exit(1)
	}

	sig, err := os.ReadFile("/tmp/qrypto_mldsa87_sig.bin")
	if err != nil {
		fmt.Printf("Failed to read signature: %v\n", err)
		os.Exit(1)
	}

	msg, err := os.ReadFile("/tmp/qrypto_mldsa87_msg.bin")
	if err != nil {
		fmt.Printf("Failed to read message: %v\n", err)
		os.Exit(1)
	}

	ctx, err := os.ReadFile("/tmp/qrypto_mldsa87_ctx.bin")
	if err != nil {
		fmt.Printf("Failed to read context: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Public key size: %d bytes\n", len(pk))
	fmt.Printf("Signature size: %d bytes\n", len(sig))
	fmt.Printf("Message size: %d bytes\n", len(msg))
	fmt.Printf("Context size: %d bytes\n", len(ctx))
	fmt.Printf("Message: %q\n", string(msg))
	fmt.Printf("Context: %q\n", string(ctx))

	// Convert to fixed-size arrays
	var pkArray [ml_dsa_87.CRYPTO_PUBLIC_KEY_BYTES]uint8
	var sigArray [ml_dsa_87.CRYPTO_BYTES]uint8

	if len(pk) != ml_dsa_87.CRYPTO_PUBLIC_KEY_BYTES {
		fmt.Printf("Invalid public key size: expected %d, got %d\n", ml_dsa_87.CRYPTO_PUBLIC_KEY_BYTES, len(pk))
		os.Exit(1)
	}
	if len(sig) != ml_dsa_87.CRYPTO_BYTES {
		fmt.Printf("Invalid signature size: expected %d, got %d\n", ml_dsa_87.CRYPTO_BYTES, len(sig))
		os.Exit(1)
	}

	copy(pkArray[:], pk)
	copy(sigArray[:], sig)

	// Verify signature with context
	valid := ml_dsa_87.Verify(ctx, msg, sigArray, &pkArray)

	if valid {
		fmt.Println("\n✓ Signature verification PASSED")
		os.Exit(0)
	} else {
		fmt.Println("\n✗ Signature verification FAILED")
		os.Exit(1)
	}
}
